import fiji.tool.AbstractTool;

import ij.*;
import ij.io.*;
import ij.process.*;
import ij.measure.*;
import ij.gui.*;
import ij.plugin.StackCombiner;

import java.awt.event.*;
import java.io.*;
import java.util.*;

import ome.xml.model.primitives.PositiveFloat;
import loci.formats.*;
import loci.plugins.util.*;
import loci.formats.meta.*;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.OutputKeys;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.TransformerFactoryConfigurationError;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;


import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;

NL = System.getProperty( "line.separator" );	
helpfont = new Font( "Arial", Font.PLAIN, 14 );
showhelp = true;


/** -------------------------------------------------------------------------------------------------------
 * Fiji Tools
 * ------------------------------------------------------------------------------------------------------ */
class CenterSelectionTool extends AbstractTool implements KeyListener, MouseListener, MouseMotionListener
{
	private ImagePlus imp;
	private int xm;
	private int ym;

	CenterSelectionTool() {
		super();
		clearToolsIfNecessary = true;
		imp = null;
		xm = -1;
		ym = -1;
	}

	public void setImagePlus( ImagePlus imp ) {
		this.imp = imp;
		this.updateOverlay();
		if ( xm>=0 && ym>=0 ) drawCropRegion();
	}

	public void updateOverlay() {
		if ( showhelp ) {
			helptext = "click at desired center of ROI" + NL +
				"use arrow keys to move ROI by pixels" + NL +
				NL +
				"press SPACE to move to next file." + NL +
				"press ESC to exit." + NL +
				NL +
				"press H to toggle help.";
			textRoi = new TextRoi( 10, 10, helptext, helpfont );
			textRoi.setStrokeColor( Color.white );
			textRoi.setNonScalable( true );
			overlay = new Overlay( textRoi );
			this.imp.setOverlay( overlay );
		} else {
			this.imp.setOverlay( null );
		}
	}
	
	public void keyPressed( KeyEvent e ) {
//		print("key");
		if ( e.getKeyCode() == KeyEvent.VK_ESCAPE ) {
			e.consume();
			dialog = new YesNoCancelDialog( null, "really?", "Do you really want to abort?" );
			if ( dialog.yesPressed() ) {
				saveAndExit();
			}
		} if ( e.getKeyCode() == KeyEvent.VK_SPACE ) {
			e.consume();
			ip = imp.getProcessor();
			ip.setRoi(roi);
			ip = ip.crop();
			String fn = outputDir + "/" + name + "_" + fileIndex + ".tif";
			omp = new ImagePlus( fn, ip );
			IJ.save( omp, fn );
			IJ.log ( "Frame saved: " + fn );
			nextFile();
		} else if ( e.getKeyCode() == KeyEvent.VK_H ) {
			e.consume();
			showhelp = !showhelp;
			this.updateOverlay();
		} else if ( e.getKeyCode() == KeyEvent.VK_UP && ym > 0 ) {
			e.consume();
			ym--;
			drawCropRegion();
		} else if ( e.getKeyCode() == KeyEvent.VK_DOWN && ym < imp.getHeight()-1 ) {
			e.consume();
			ym++;
			drawCropRegion();
		} else if ( e.getKeyCode() == KeyEvent.VK_LEFT && xm > 0 ) {
			e.consume();
			xm--;
			drawCropRegion();
		} else if ( e.getKeyCode() == KeyEvent.VK_RIGHT && xm < imp.getWidth()-1 ) {
			e.consume();
			xm++;
			drawCropRegion();
		}
	}
	
	public void keyReleased( KeyEvent e ) {
		e.consume();
	}
	
	public void keyTyped( KeyEvent e ) {
		e.consume();
	}

	public void mousePressed( MouseEvent e ) {
		showhelp = false;
		this.updateOverlay();
		
		canvas = this.imp.getWindow().getCanvas();
		if ( e.getComponent() != canvas ) {
			print( "wrong canvas" );
			return;
		}

		if ( e.getButton() == MouseEvent.BUTTON1 ) {
			xm = canvas.offScreenX( e.getX() );
			ym = canvas.offScreenY( e.getY() );
			drawCropRegion();
		}
		e.consume();
	}

	public void mouseReleased( MouseEvent e ){}
	public void mouseExited( MouseEvent e ){}
	public void mouseClicked( MouseEvent e ){}
	public void mouseEntered( MouseEvent e ){}

	public void mouseDragged( MouseEvent e ) {
		e.consume();
	}
	
	public void mouseMoved( MouseEvent e ){}
	
	public String getToolName() {
		return "Center Selector";
	}

	private void drawCropRegion() {
		x = xm - (width/2);
		y = ym - (height/2);
		x = Math.max(x,0);
		y = Math.max(y,0);
		x = Math.min(x, imp.getWidth()-width);
		y = Math.min(y, imp.getHeight()-height);
		roi = new Roi(x, y, width, height);
		imp.setOverlay(roi, Color.GREEN, 2, null);
		oval = new OvalRoi(xm-5,ym-5,10,10);
		imp.setRoi(oval);
	}
}

/** -------------------------------------------------------------------------------------------------------
 * Classes and Methods and User Interactions
 * ------------------------------------------------------------------------------------------------------ */
GenericDialog getOptions() {  
	gd = new GenericDialog("Options");  
	gd.addStringField("prefix", "frame");  
	gd.addNumericField("width", 300, 0);
	gd.addNumericField("height", 200, 0);  
	gd.showDialog();

	if ( gd.wasCanceled() ) {  
		System.out.println ("User canceled dialog!");  
    		return null;
	}
	return gd;
}
  
/** -------------------------------------------------------------------------------------------------------
 * Utilities
 * ------------------------------------------------------------------------------------------------------ */

/**
 * Filters files named "*.xml".
 */
class TifFileFilter implements FilenameFilter {
	final static private String regex = ".*\\.tif";

	public boolean accept( File dir, String name ) {
		if ( name.matches( regex ) ) {
			final File file = new File( dir, name );
			return file.exists() && file.isFile();
		} else {
			return false;
		}
	}
}

/**
 * Load all .tif-files form a given folder...
 */
String[] getTifFilesFromFolder( String inputDir ) {
	File dir = new File( inputDir );
	String[] tifFiles = dir.list( new TifFileFilter() );
	return ( tifFiles );
}

void saveAndExit()
{
	IJ.log( "...done!" );
	display.close();
}

/* Process next file, depends on having a directory with imges selected */
void nextFile() {
	++fileIndex;
	print( "impfile = " + impFile );

	if ( fileIndex >= fileNames.length )
	{
		saveAndExit();
		return;
	}

	/* try to open file */
	fileName = inputDir + "/" + fileNames[ fileIndex ];
	impFile = new ImagePlus( fileName );

	if ( impFile != null )
	{
		IJ.log( "Opened File `" + fileName + "'." );

		/* show the new image */
//		impFile.show();
		display.setProcessor( impFile.getProcessor() );
		
		/* select the right tool again */
		centerSelectionTool.setImagePlus( display );
		IJ.setTool( centerSelectionToolId );
	}
	else
		IJ.log( "File `" + fileName + "' not found." );
}

/** -------------------------------------------------------------------------------------------------------
 * The script follows now:
 * ------------------------------------------------------------------------------------------------------ */

IJ.log ( "Start manual tracking script..." );
IJ.run( "Install...", "install=[" + IJ.getDirectory( "macros" ) + "toolsets/Clear Custom Tools.txt]" );

options = getOptions();  
if ( options != null ) {
	name   = options.getNextString();
	width  = (int)options.getNextNumber();
	height = (int)options.getNextNumber();
	roi = new Roi(0, 0, width, height);
	print ( name );
	print ( width/2 );
	print ( height/2 );
} else {
	print ("Script canceled!");
	return;
}

display = new ImagePlus( "frame to crop", new ByteProcessor(10,10) );
display.show();
	
dc = new DirectoryChooser( "Choose a directory (" );
if ( dc != null ) {
	inputDir = dc.getDirectory();
	outputDir = ""+inputDir+"/output";
	success = (new File(outputDir)).mkdirs();
	if (!success) {
	    IJ.log ( "Output-folder might exist: " + outputDir );
	}
	fileNames = getTifFilesFromFolder( inputDir );
	fileIndex = -1;

	centerSelectionTool = new CenterSelectionTool();
	centerSelectionTool.run( "" );
	centerSelectionToolId = Toolbar.getInstance().getToolId( "Center Selector" );

	impFile = null; // this will be the open file
	nextFile();
} else {
	print ("Script canceled!");
	return;
}

